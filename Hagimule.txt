Hagimule est une application qui doit permettre le téléchargement de plusieurs fichiers lorsque plusieurs client 
qui possède le même fichier sont connectés simultanément. Ainsi plus il y a de client qui possède un fichier plus 
on augmente la vitesse de téléchargement de celui-ci.

L'application se composent de plusieur classe en java dont les rôles vont être expliqué ici:

Les classes Diary qui font la gestion de l'annuaire : 
- DiaryInterface.java : description de l'interface de l'annuaire avec les méthode permettant d'enregistrer les fichiers 
                        des clients et de récupérer la liste des clients qui possède un fichier  
    - TODO (rajouter taille de fichier) registerFile : enregistre un fichier dans l'annuiare avec les clients qui le possède ainsi que la taille du fichier
    - getClient : récupère la liste des clients qui possède un fichier à partir d'un nom de fichier
    - TODO : La méthode getAllClient : récupère la liste de tous les clients 
- DiaryImpl.java : Implémentation de l'interface de l'annuaire avec RMI 
    TODO : implémenter DiaryInterface
- DiaryServer.java : main utilise l'implémentation de l'annuaire pour qu'il fonctionne comme un serveur sur le port 1099
    - main : crée le diary, le met sur le serveur (les daemons peuvent alors récupérer l'annuiare grace au nom de port)


La classe Daemon : TODO repartir à zéro
- Dans le main on créé un Daemon, on le lance et on lance la méthode registerCustomer
- La méthode registerCustomer permet d'enregistrer un Client=Daemon dans l'annuaire (ses fichers etc ...)



TODO :
- Dans l'idée modifier la classe downloader en modifiant le nom downloader par main (pour le lancer automatiquement) et garder downlodFragmennt
- Modifier l'entrée du diary <List[Clients],fileSize> (on ajoute le fileSize)
- créer une fonction qui récupère tous les clients de l'annuaire dans la classe DiaryImpl
- ajouter une fonction qui permet d'enregistrer pour chaque daemon le client (un client = un daemon = une machine)
- créer les fichiers de test
- créer un fichier makefile et mettre :     
    - lance la classe Serveur qui crée l'annuaire en RMI
    - créer les daemons (penser à se connecter se connecter)
Bonus :
- Rajouter dans l'annuaire le client qui vient de télécharger le fichier (dans la classe Downloader) c'est à dire la machine que l'on utilise pour lancer le projet si il veut devenir hébergeur


Etapes de fonctionnement : 
- Se connecter en ssh sur plusieurs machine = ça crée différents daemon qui possède alors automatiquement tous les fichiers de tests (MAKEFILE)
- On ajoute ces daemons dans l'annuaire qui possèdent donc tous les fichiers de test (se fait automatiquement grace au main du daemon)
- On lance le téléchargement d'un fichier (MAKEILE)
    - On récupère la liste des clients (DOWNLOADER : main)
    - On fractionne la taille en fonction du nombre de client (DOWNLOADER : main)
    - On écrit dans un nouveau fichier sur la machine qui lance le projet, les fractions de fichier (penser à les mettre dans l'ordre) (DOWNLOADER : main qui utilise downloadFragments)
        - Quand on demande à un daemon de télécharger une certaine zone de fichier, on connaît cette zone et donc dès que le thread a fini on écrit 
          dans la zone du nouveau fichier 
        - PS : on peut écrire par exemple de l'octet 5 à 10 même si le fichier initial est vide (les octets 0 à 5 ne sont juste pas initialisés)


Fonctionnement des fichiers/daemons :
- On se connecte en ssh sur une autre machine
- Les fichiers tests sont donc sur cette machine (Dans un dossier fichierTest par exemple)
- On crée un daemon sur cette machine
- Ce daemon possède alors les fichiers de test présent dans le dossier dossierFichierTest
- Lorsque l'on crée le daemon, on va aller regarder le dossier dossierFichierTest et récupérer les fichiers présents pour les enregistrer avec le daemon dans l'annuaire
- Donc chaque daemon = une machine = un client = une connection ssh ...





Ancien fichier daemon :
public void start(){
         //Initialisation du serveur sur le port 1099
         try (ServerSocket serverSocket = new ServerSocket(PORT)){
            //Debug
            System.out.println("Daemon en cours ... " + PORT);
            while (true) {
                //Attente de connexion d'un client
                Socket socket = serverSocket.accept();
                //Démarrage d'un thread pour gérer la connexion avec le client 
                FileHandler fileHandler = new FileHandler(socket);
                new Thread(fileHandler).start();
            }        
        } catch (IOException e){
            e.printStackTrace();
        }
    }

    public void registerCustomer(){
        // Connexion à l'annuaire RMI qui se trouve sur le port 1099
            Registry registry = LocateRegistry.getRegistry("localhost", 1099);
        // Recherche de l'objet "Annuaire" dans l'annuaire RMI
            DiaryImpl diary = (DiaryImpl) registry.lookup("Annuaire");
        // Récupérer les valeurs dans le diary
        for (Map.Entry<String, String> entry : .entrySet()) {
            String value = entry.getValue();
        }
    }

// Pour le client, on peut utiliser le code suivant pour envoyer un fichier au serveur
class FileHandler implements Runnable {
    private final Socket socket;

    //Constructeur
    public FileHandler(Socket socket) {
        this.socket = socket;
    }

    //Méthode run qui sera exécutée
    @Override
    public void run() {
        //Initialisation des flux d'entrée et de sortie
        try (DataInputStream in = new DataInputStream(socket.getInputStream());
             DataOutputStream out = new DataOutputStream(socket.getOutputStream())) {
            
            //Lecture du nom du fichier
            String fileName = in.readUTF();
            //Lecture du decalage (point de départ de lecture)
            long offset = in.readLong();
            //Lecture de la longueur du fichier
            int length = in.readInt();

            //Création d'un objet File et vérification de l'existence du fichier
            File file = new File(fileName);
            if (!file.exists()) {
                out.writeBoolean(false);
                return;
            }
            out.writeBoolean(true);

            //Lecture du fichier et envoi au client
            try (RandomAccessFile raf = new RandomAccessFile(file, "r")) {
                //Création d'un buffer pour stocker les données de la taille du fichier
                byte[] buffer = new byte[length];
                //Déplacement du curseur à l'endroit spécifié
                raf.seek(offset);
                //Lecture du fichier
                raf.read(buffer);

                //Envoie de la taille du fichier au client et du fichier 
                out.writeInt(buffer.length);
                out.write(buffer);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

ancien Dowloader :
import java.io.*;
import java.net.*;
import java.util.concurrent.*;


public class Downloader {
    //ExecutorService pour gérer les threads (ici 4 threads à changer selon les performances de Hagimule)
    private final ExecutorService executor = Executors.newFixedThreadPool(4);

    //Méthode pour télécharger un fichier à partir de plusieurs clients
    public void download(String[] clients, String fileName, long fileSize) throws IOException {

        //Calcul de la taille de chaque fragment
        long fragmentSize = fileSize / clients.length;
        try {
            for (int i = 0; i < clients.length; i++) {
                //On applique un décallage à chaque itération pour télécharger la bonne partie du fichier
                long offset = i * fragmentSize;
                //Calcul de la taille du fragment que l'on doit télécharger
                long length;
                //On regarde si le client est le dernier de la liste
                if (i == clients.length - 1){
                    //Si oui la taille du dernier fragment n'est surement pas de la taille des autres fragments
                    length = (fileSize - offset) ;
                }else{
                    //Sinon on utilise la même taille que les autres fragments
                    length = fragmentSize;
                }
                
                //On stocke le numéro du client courant
                int finalI = i;
                //Pour chaque client on télécharge le fragment.
                executor.submit(() -> downloadFragments(clients[finalI], fileName, offset, length));
            }

            //Pour que l'executor ne prennent plus de tâche j'usqu'à la fin des autres tâches
            executor.shutdown();
            //On attend que les tâches soient terminé ou que le temps soit terminé (ici 1 heure (à modifier surement))
            executor.awaitTermination(1, TimeUnit.HOURS);

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }  

    public void downloadFragments(String client, String fileName, long offset, long length) {
            try (Socket socket = new Socket(client, Daemon.PORT);
                 DataInputStream in = new DataInputStream(socket.getInputStream());
                 RandomAccessFile raf = new RandomAccessFile(fileName, "rw")) {
        
                // Envoi de la requête au daemon
                DataOutputStream out = new DataOutputStream(socket.getOutputStream());
                out.writeUTF(fileName);
                out.writeLong(offset);
                out.writeInt(Math.toIntExact(length));
    
            // Vérifier si le fichier est accessible
            if (!in.readBoolean()) {
                System.err.println("Fragment non disponible");
                return;
            }
    
            // Lecture des données reçues
            int fragmentSize = in.readInt();
            byte[] buffer = new byte[fragmentSize];
            in.readFully(buffer);
    
            // Écriture directe dans le fichier à l'emplacement approprié
            raf.seek(offset);
            raf.write(buffer);
    
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}

